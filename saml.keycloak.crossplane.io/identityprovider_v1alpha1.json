{
  "description": "IdentityProvider is the Schema for the IdentityProviders API.",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "IdentityProviderSpec defines the desired state of IdentityProvider",
      "properties": {
        "deletionPolicy": {
          "default": "Delete",
          "description": "DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either \"Delete\" or \"Orphan\" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "enum": [
            "Orphan",
            "Delete"
          ],
          "type": "string"
        },
        "forProvider": {
          "properties": {
            "addReadTokenRoleOnCreate": {
              "description": "When true, new users will be able to read stored tokens. This will automatically assign the broker.read-token role. Defaults to false.\nEnable/disable if new users can read any stored tokens. This assigns the broker.read-token role.",
              "type": "boolean"
            },
            "alias": {
              "description": "The unique name of identity provider.\nThe alias uniquely identifies an identity provider and it is also used to build the redirect uri.",
              "type": "string"
            },
            "authenticateByDefault": {
              "description": "Authenticate users by default. Defaults to false.\nEnable/disable authenticate users by default.",
              "type": "boolean"
            },
            "authnContextClassRefs": {
              "description": "Ordered list of requested AuthnContext ClassRefs.\nAuthnContext ClassRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "authnContextComparisonType": {
              "description": "Specifies the comparison method used to evaluate the requested context classes or statements.\nAuthnContext Comparison",
              "type": "string"
            },
            "authnContextDeclRefs": {
              "description": "Ordered list of requested AuthnContext DeclRefs.\nAuthnContext DeclRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "backchannelSupported": {
              "description": "Does the external IDP support backchannel logout?. Defaults to false.\nDoes the external IDP support backchannel logout?",
              "type": "boolean"
            },
            "displayName": {
              "description": "The display name for the realm that is shown when logging in to the admin console.\nFriendly name for Identity Providers.",
              "type": "string"
            },
            "enabled": {
              "description": "When false, users and clients will not be able to access this realm. Defaults to true.\nEnable/disable this identity provider.",
              "type": "boolean"
            },
            "entityId": {
              "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\nThe Entity ID that will be used to uniquely identify this SAML Service Provider.",
              "type": "string"
            },
            "extraConfig": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map of key/value pairs to add extra configuration to this identity provider. Use this attribute at your own risk, as custom attributes may conflict with top-level configuration attributes in future provider updates.",
              "type": "object",
              "x-kubernetes-map-type": "granular"
            },
            "firstBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to first broker login.\nAlias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.",
              "type": "string"
            },
            "forceAuthn": {
              "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\nRequire Force Authn.",
              "type": "boolean"
            },
            "guiOrder": {
              "description": "A number defining the order of this identity provider in the GUI.\nGUI Order",
              "type": "string"
            },
            "hideOnLoginPage": {
              "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\nHide On Login Page.",
              "type": "boolean"
            },
            "linkOnly": {
              "description": "When true, users cannot log in using this provider, but their existing accounts will be linked when possible. Defaults to false.\nIf true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider",
              "type": "boolean"
            },
            "loginHint": {
              "description": "Login Hint.",
              "type": "string"
            },
            "nameIdPolicyFormat": {
              "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\nName ID Policy Format.",
              "type": "string"
            },
            "orgDomain": {
              "description": "The organization domain to associate this identity provider with. It is used to map users to an organization based on their email domain and to authenticate them accordingly in the scope of the organization.",
              "type": "string"
            },
            "orgRedirectModeEmailMatches": {
              "description": "Indicates whether to automatically redirect users to this identity provider when email domain matches domain.",
              "type": "boolean"
            },
            "organizationId": {
              "description": "The ID of the organization to link this identity provider to.\nID of organization with which this identity is linked.",
              "type": "string"
            },
            "organizationIdRef": {
              "description": "Reference to a Organization in organization to populate organizationId.",
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "required": [
                "name"
              ],
              "type": "object",
              "additionalProperties": false
            },
            "organizationIdSelector": {
              "description": "Selector for a Organization in organization to populate organizationId.",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "postBindingAuthnRequest": {
              "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Authn Request.",
              "type": "boolean"
            },
            "postBindingLogout": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Logout.",
              "type": "boolean"
            },
            "postBindingResponse": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Response.",
              "type": "boolean"
            },
            "postBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\nAlias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.",
              "type": "string"
            },
            "principalAttribute": {
              "description": "The principal attribute.\nPrincipal Attribute",
              "type": "string"
            },
            "principalType": {
              "description": "The principal type. Can be one of SUBJECT, ATTRIBUTE or FRIENDLY_ATTRIBUTE.\nPrincipal Type",
              "type": "string"
            },
            "providerId": {
              "description": "The ID of the identity provider to use. Defaults to saml, which should be used unless you have extended Keycloak and provided your own implementation.\nprovider id, is always saml, unless you have a custom implementation",
              "type": "string"
            },
            "realm": {
              "description": "The name of the realm. This is unique across Keycloak.\nRealm Name",
              "type": "string"
            },
            "realmRef": {
              "description": "Reference to a Realm in realm to populate realm.",
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "required": [
                "name"
              ],
              "type": "object",
              "additionalProperties": false
            },
            "realmSelector": {
              "description": "Selector for a Realm in realm to populate realm.",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "signatureAlgorithm": {
              "description": "Signing Algorithm. Defaults to empty.\nSigning Algorithm.",
              "type": "string"
            },
            "signingCertificate": {
              "description": "Signing Certificate.\nSigning Certificate.",
              "type": "string"
            },
            "singleLogoutServiceUrl": {
              "description": "The Url that must be used to send logout requests.\nLogout URL.",
              "type": "string"
            },
            "singleSignOnServiceUrl": {
              "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\nSSO Logout URL.",
              "type": "string"
            },
            "storeToken": {
              "description": "When true, tokens will be stored after authenticating users. Defaults to true.\nEnable/disable if tokens must be stored after authenticating users.",
              "type": "boolean"
            },
            "syncMode": {
              "description": "The default sync mode to use for all mappers attached to this identity provider. Can be one of IMPORT, FORCE, or LEGACY.\nSync Mode",
              "type": "string"
            },
            "trustEmail": {
              "description": "When true, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to false.\nIf enabled then email provided by this provider is not verified even if verification is enabled for the realm.",
              "type": "boolean"
            },
            "validateSignature": {
              "description": "Enable/disable signature validation of SAML responses.\nEnable/disable signature validation of SAML responses.",
              "type": "boolean"
            },
            "wantAssertionsEncrypted": {
              "description": "Indicates whether this service provider expects an encrypted Assertion.\nWant Assertions Encrypted.",
              "type": "boolean"
            },
            "wantAssertionsSigned": {
              "description": "Indicates whether this service provider expects a signed Assertion.\nWant Assertions Signed.",
              "type": "boolean"
            },
            "xmlSignKeyInfoKeyNameTransformer": {
              "description": "The SAML signature key name. Can be one of NONE, KEY_ID, or CERT_SUBJECT.\nSign Key Transformer.",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "initProvider": {
          "description": "THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.",
          "properties": {
            "addReadTokenRoleOnCreate": {
              "description": "When true, new users will be able to read stored tokens. This will automatically assign the broker.read-token role. Defaults to false.\nEnable/disable if new users can read any stored tokens. This assigns the broker.read-token role.",
              "type": "boolean"
            },
            "alias": {
              "description": "The unique name of identity provider.\nThe alias uniquely identifies an identity provider and it is also used to build the redirect uri.",
              "type": "string"
            },
            "authenticateByDefault": {
              "description": "Authenticate users by default. Defaults to false.\nEnable/disable authenticate users by default.",
              "type": "boolean"
            },
            "authnContextClassRefs": {
              "description": "Ordered list of requested AuthnContext ClassRefs.\nAuthnContext ClassRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "authnContextComparisonType": {
              "description": "Specifies the comparison method used to evaluate the requested context classes or statements.\nAuthnContext Comparison",
              "type": "string"
            },
            "authnContextDeclRefs": {
              "description": "Ordered list of requested AuthnContext DeclRefs.\nAuthnContext DeclRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "backchannelSupported": {
              "description": "Does the external IDP support backchannel logout?. Defaults to false.\nDoes the external IDP support backchannel logout?",
              "type": "boolean"
            },
            "displayName": {
              "description": "The display name for the realm that is shown when logging in to the admin console.\nFriendly name for Identity Providers.",
              "type": "string"
            },
            "enabled": {
              "description": "When false, users and clients will not be able to access this realm. Defaults to true.\nEnable/disable this identity provider.",
              "type": "boolean"
            },
            "entityId": {
              "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\nThe Entity ID that will be used to uniquely identify this SAML Service Provider.",
              "type": "string"
            },
            "extraConfig": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map of key/value pairs to add extra configuration to this identity provider. Use this attribute at your own risk, as custom attributes may conflict with top-level configuration attributes in future provider updates.",
              "type": "object",
              "x-kubernetes-map-type": "granular"
            },
            "firstBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to first broker login.\nAlias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.",
              "type": "string"
            },
            "forceAuthn": {
              "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\nRequire Force Authn.",
              "type": "boolean"
            },
            "guiOrder": {
              "description": "A number defining the order of this identity provider in the GUI.\nGUI Order",
              "type": "string"
            },
            "hideOnLoginPage": {
              "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\nHide On Login Page.",
              "type": "boolean"
            },
            "linkOnly": {
              "description": "When true, users cannot log in using this provider, but their existing accounts will be linked when possible. Defaults to false.\nIf true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider",
              "type": "boolean"
            },
            "loginHint": {
              "description": "Login Hint.",
              "type": "string"
            },
            "nameIdPolicyFormat": {
              "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\nName ID Policy Format.",
              "type": "string"
            },
            "orgDomain": {
              "description": "The organization domain to associate this identity provider with. It is used to map users to an organization based on their email domain and to authenticate them accordingly in the scope of the organization.",
              "type": "string"
            },
            "orgRedirectModeEmailMatches": {
              "description": "Indicates whether to automatically redirect users to this identity provider when email domain matches domain.",
              "type": "boolean"
            },
            "organizationId": {
              "description": "The ID of the organization to link this identity provider to.\nID of organization with which this identity is linked.",
              "type": "string"
            },
            "organizationIdRef": {
              "description": "Reference to a Organization in organization to populate organizationId.",
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "required": [
                "name"
              ],
              "type": "object",
              "additionalProperties": false
            },
            "organizationIdSelector": {
              "description": "Selector for a Organization in organization to populate organizationId.",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "postBindingAuthnRequest": {
              "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Authn Request.",
              "type": "boolean"
            },
            "postBindingLogout": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Logout.",
              "type": "boolean"
            },
            "postBindingResponse": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Response.",
              "type": "boolean"
            },
            "postBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\nAlias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.",
              "type": "string"
            },
            "principalAttribute": {
              "description": "The principal attribute.\nPrincipal Attribute",
              "type": "string"
            },
            "principalType": {
              "description": "The principal type. Can be one of SUBJECT, ATTRIBUTE or FRIENDLY_ATTRIBUTE.\nPrincipal Type",
              "type": "string"
            },
            "providerId": {
              "description": "The ID of the identity provider to use. Defaults to saml, which should be used unless you have extended Keycloak and provided your own implementation.\nprovider id, is always saml, unless you have a custom implementation",
              "type": "string"
            },
            "realm": {
              "description": "The name of the realm. This is unique across Keycloak.\nRealm Name",
              "type": "string"
            },
            "realmRef": {
              "description": "Reference to a Realm in realm to populate realm.",
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "required": [
                "name"
              ],
              "type": "object",
              "additionalProperties": false
            },
            "realmSelector": {
              "description": "Selector for a Realm in realm to populate realm.",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "properties": {
                    "resolution": {
                      "default": "Required",
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "enum": [
                        "Required",
                        "Optional"
                      ],
                      "type": "string"
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "signatureAlgorithm": {
              "description": "Signing Algorithm. Defaults to empty.\nSigning Algorithm.",
              "type": "string"
            },
            "signingCertificate": {
              "description": "Signing Certificate.\nSigning Certificate.",
              "type": "string"
            },
            "singleLogoutServiceUrl": {
              "description": "The Url that must be used to send logout requests.\nLogout URL.",
              "type": "string"
            },
            "singleSignOnServiceUrl": {
              "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\nSSO Logout URL.",
              "type": "string"
            },
            "storeToken": {
              "description": "When true, tokens will be stored after authenticating users. Defaults to true.\nEnable/disable if tokens must be stored after authenticating users.",
              "type": "boolean"
            },
            "syncMode": {
              "description": "The default sync mode to use for all mappers attached to this identity provider. Can be one of IMPORT, FORCE, or LEGACY.\nSync Mode",
              "type": "string"
            },
            "trustEmail": {
              "description": "When true, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to false.\nIf enabled then email provided by this provider is not verified even if verification is enabled for the realm.",
              "type": "boolean"
            },
            "validateSignature": {
              "description": "Enable/disable signature validation of SAML responses.\nEnable/disable signature validation of SAML responses.",
              "type": "boolean"
            },
            "wantAssertionsEncrypted": {
              "description": "Indicates whether this service provider expects an encrypted Assertion.\nWant Assertions Encrypted.",
              "type": "boolean"
            },
            "wantAssertionsSigned": {
              "description": "Indicates whether this service provider expects a signed Assertion.\nWant Assertions Signed.",
              "type": "boolean"
            },
            "xmlSignKeyInfoKeyNameTransformer": {
              "description": "The SAML signature key name. Can be one of NONE, KEY_ID, or CERT_SUBJECT.\nSign Key Transformer.",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "managementPolicies": {
          "default": [
            "*"
          ],
          "description": "THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ],
            "type": "string"
          },
          "type": "array"
        },
        "providerConfigRef": {
          "default": {
            "name": "default"
          },
          "description": "ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.",
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "properties": {
                "resolution": {
                  "default": "Required",
                  "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                  "enum": [
                    "Required",
                    "Optional"
                  ],
                  "type": "string"
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ],
                  "type": "string"
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          },
          "required": [
            "name"
          ],
          "type": "object",
          "additionalProperties": false
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.",
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          },
          "required": [
            "name",
            "namespace"
          ],
          "type": "object",
          "additionalProperties": false
        }
      },
      "required": [
        "forProvider"
      ],
      "type": "object",
      "x-kubernetes-validations": [
        {
          "message": "spec.forProvider.alias is a required parameter",
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.alias) || (has(self.initProvider) && has(self.initProvider.alias))"
        },
        {
          "message": "spec.forProvider.entityId is a required parameter",
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.entityId) || (has(self.initProvider) && has(self.initProvider.entityId))"
        },
        {
          "message": "spec.forProvider.singleSignOnServiceUrl is a required parameter",
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.singleSignOnServiceUrl) || (has(self.initProvider) && has(self.initProvider.singleSignOnServiceUrl))"
        }
      ],
      "additionalProperties": false
    },
    "status": {
      "description": "IdentityProviderStatus defines the observed state of IdentityProvider.",
      "properties": {
        "atProvider": {
          "properties": {
            "addReadTokenRoleOnCreate": {
              "description": "When true, new users will be able to read stored tokens. This will automatically assign the broker.read-token role. Defaults to false.\nEnable/disable if new users can read any stored tokens. This assigns the broker.read-token role.",
              "type": "boolean"
            },
            "alias": {
              "description": "The unique name of identity provider.\nThe alias uniquely identifies an identity provider and it is also used to build the redirect uri.",
              "type": "string"
            },
            "authenticateByDefault": {
              "description": "Authenticate users by default. Defaults to false.\nEnable/disable authenticate users by default.",
              "type": "boolean"
            },
            "authnContextClassRefs": {
              "description": "Ordered list of requested AuthnContext ClassRefs.\nAuthnContext ClassRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "authnContextComparisonType": {
              "description": "Specifies the comparison method used to evaluate the requested context classes or statements.\nAuthnContext Comparison",
              "type": "string"
            },
            "authnContextDeclRefs": {
              "description": "Ordered list of requested AuthnContext DeclRefs.\nAuthnContext DeclRefs",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "backchannelSupported": {
              "description": "Does the external IDP support backchannel logout?. Defaults to false.\nDoes the external IDP support backchannel logout?",
              "type": "boolean"
            },
            "displayName": {
              "description": "The display name for the realm that is shown when logging in to the admin console.\nFriendly name for Identity Providers.",
              "type": "string"
            },
            "enabled": {
              "description": "When false, users and clients will not be able to access this realm. Defaults to true.\nEnable/disable this identity provider.",
              "type": "boolean"
            },
            "entityId": {
              "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\nThe Entity ID that will be used to uniquely identify this SAML Service Provider.",
              "type": "string"
            },
            "extraConfig": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map of key/value pairs to add extra configuration to this identity provider. Use this attribute at your own risk, as custom attributes may conflict with top-level configuration attributes in future provider updates.",
              "type": "object",
              "x-kubernetes-map-type": "granular"
            },
            "firstBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to first broker login.\nAlias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.",
              "type": "string"
            },
            "forceAuthn": {
              "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\nRequire Force Authn.",
              "type": "boolean"
            },
            "guiOrder": {
              "description": "A number defining the order of this identity provider in the GUI.\nGUI Order",
              "type": "string"
            },
            "hideOnLoginPage": {
              "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\nHide On Login Page.",
              "type": "boolean"
            },
            "id": {
              "type": "string"
            },
            "internalId": {
              "description": "Internal Identity Provider Id",
              "type": "string"
            },
            "linkOnly": {
              "description": "When true, users cannot log in using this provider, but their existing accounts will be linked when possible. Defaults to false.\nIf true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider",
              "type": "boolean"
            },
            "loginHint": {
              "description": "Login Hint.",
              "type": "string"
            },
            "nameIdPolicyFormat": {
              "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\nName ID Policy Format.",
              "type": "string"
            },
            "orgDomain": {
              "description": "The organization domain to associate this identity provider with. It is used to map users to an organization based on their email domain and to authenticate them accordingly in the scope of the organization.",
              "type": "string"
            },
            "orgRedirectModeEmailMatches": {
              "description": "Indicates whether to automatically redirect users to this identity provider when email domain matches domain.",
              "type": "boolean"
            },
            "organizationId": {
              "description": "The ID of the organization to link this identity provider to.\nID of organization with which this identity is linked.",
              "type": "string"
            },
            "postBindingAuthnRequest": {
              "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Authn Request.",
              "type": "boolean"
            },
            "postBindingLogout": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Logout.",
              "type": "boolean"
            },
            "postBindingResponse": {
              "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nPost Binding Response.",
              "type": "boolean"
            },
            "postBrokerLoginFlowAlias": {
              "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\nAlias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.",
              "type": "string"
            },
            "principalAttribute": {
              "description": "The principal attribute.\nPrincipal Attribute",
              "type": "string"
            },
            "principalType": {
              "description": "The principal type. Can be one of SUBJECT, ATTRIBUTE or FRIENDLY_ATTRIBUTE.\nPrincipal Type",
              "type": "string"
            },
            "providerId": {
              "description": "The ID of the identity provider to use. Defaults to saml, which should be used unless you have extended Keycloak and provided your own implementation.\nprovider id, is always saml, unless you have a custom implementation",
              "type": "string"
            },
            "realm": {
              "description": "The name of the realm. This is unique across Keycloak.\nRealm Name",
              "type": "string"
            },
            "signatureAlgorithm": {
              "description": "Signing Algorithm. Defaults to empty.\nSigning Algorithm.",
              "type": "string"
            },
            "signingCertificate": {
              "description": "Signing Certificate.\nSigning Certificate.",
              "type": "string"
            },
            "singleLogoutServiceUrl": {
              "description": "The Url that must be used to send logout requests.\nLogout URL.",
              "type": "string"
            },
            "singleSignOnServiceUrl": {
              "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\nSSO Logout URL.",
              "type": "string"
            },
            "storeToken": {
              "description": "When true, tokens will be stored after authenticating users. Defaults to true.\nEnable/disable if tokens must be stored after authenticating users.",
              "type": "boolean"
            },
            "syncMode": {
              "description": "The default sync mode to use for all mappers attached to this identity provider. Can be one of IMPORT, FORCE, or LEGACY.\nSync Mode",
              "type": "string"
            },
            "trustEmail": {
              "description": "When true, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to false.\nIf enabled then email provided by this provider is not verified even if verification is enabled for the realm.",
              "type": "boolean"
            },
            "validateSignature": {
              "description": "Enable/disable signature validation of SAML responses.\nEnable/disable signature validation of SAML responses.",
              "type": "boolean"
            },
            "wantAssertionsEncrypted": {
              "description": "Indicates whether this service provider expects an encrypted Assertion.\nWant Assertions Encrypted.",
              "type": "boolean"
            },
            "wantAssertionsSigned": {
              "description": "Indicates whether this service provider expects a signed Assertion.\nWant Assertions Signed.",
              "type": "boolean"
            },
            "xmlSignKeyInfoKeyNameTransformer": {
              "description": "The SAML signature key name. Can be one of NONE, KEY_ID, or CERT_SUBJECT.\nSign Key Transformer.",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "conditions": {
          "description": "Conditions of the resource.",
          "items": {
            "description": "A Condition that may apply to a resource.",
            "properties": {
              "lastTransitionTime": {
                "description": "LastTransitionTime is the last time this condition transitioned from one\nstatus to another.",
                "format": "date-time",
                "type": "string"
              },
              "message": {
                "description": "A Message containing details about this condition's last transition from\none status to another, if any.",
                "type": "string"
              },
              "observedGeneration": {
                "description": "ObservedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "format": "int64",
                "type": "integer"
              },
              "reason": {
                "description": "A Reason for this condition's last transition from one status to another.",
                "type": "string"
              },
              "status": {
                "description": "Status of this condition; is it currently True, False, or Unknown?",
                "type": "string"
              },
              "type": {
                "description": "Type of this condition. At most one of each condition type may apply to\na resource at any point in time.",
                "type": "string"
              }
            },
            "required": [
              "lastTransitionTime",
              "reason",
              "status",
              "type"
            ],
            "type": "object",
            "additionalProperties": false
          },
          "type": "array",
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the latest metadata.generation\nwhich resulted in either a ready state, or stalled due to error\nit can not recover from without human intervention.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object",
      "additionalProperties": false
    }
  },
  "required": [
    "spec"
  ],
  "type": "object"
}
